---
title: Redis相关问题及解决方案
date: 2025-02-18 21:39:59
tags: 
---

# Redis相关问题及解决方案

## 缓存穿透
**问题描述**

当出现大量对某个不存在的key的访问时，由于存储层查不到数据而不会写入缓存，会一直在数据库中进行查询，导致数据库承受很大的查询压力。可能是遭到了攻击。

**解决方案**

可以采用布隆过滤器解决
布隆过滤器使用bitmap存储数据是否在数据库中存在
先初始化一个大数组，里面存放0和1，一开始都是0，当查询到某个key的时候，对其经过3次哈希计算，将模数组长度的下标的数组的值由0改为1。这样3个位置可以标明一个key的存在。但是有误判的概率，不过可以接受。

## 缓存击穿
**问题描述**

对于某个设置了过期时间的key，在其过期的时间点恰好有对这个key有大量的并发请求。由于缓存过期，会全部转发到数据库，导致数据库承受巨大压力。

**解决方案**

方案一：采用互斥锁
当缓存失效时，先使用Redis的setnx设置互斥锁，再查询数据库并写入缓存，拿不到锁就重复尝试读取缓存。

方案二：逻辑过期
在存入缓存时，对key添加一个过期时间戳，不设置过期时间。当查询到key的时候，检测其是否过期。如果过期，先放回过期数据。并单开一个新线程进行读取数据库写入缓存操作。不过数据不能保持强一致，但确保了高可用性。

## 缓存雪崩
**问题描述**

大量同时过期的key，在过期的时间点出现大量并发请求。请求全部转发到数据库，数据库承受巨大压力而雪崩。

**解决方案**

可以在设置key的过期时间时，添加随机的偏移量，使他们不会同时过期。

---
*以上三种问题均可以通过使用Nginx或者Gateway限流的方式解决，可以作为最后的保底解决方案*

# 双写一致性
**问题描述**

需要让数据库和Redis缓存的数据保持一致

**解决方案**

强一致：
使用Redisson的读写锁，读锁采用共享锁
更新数据时，采用setnx的排他锁，使其他操作均与其互斥，保持数据一致性。

非强一致：延迟双删
更新数据时，先删除缓存，更新数据库，再延时删除缓存。延时不好确定，且可能导致短时间的数据不一致。

也可以更新数据时将消息发送给MQ，再监听MQ的消息更新缓存。
或者使用Canal，Canal会伪装成数据库的一个从节点，数据更新时，Canal读取binlog数据，再更新缓存。